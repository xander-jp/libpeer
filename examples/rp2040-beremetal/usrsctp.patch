diff --git a/usrsctplib/netinet/sctp_pcb.c b/usrsctplib/netinet/sctp_pcb.c
index 1f36c3a..b8a2a76 100755
--- a/usrsctplib/netinet/sctp_pcb.c
+++ b/usrsctplib/netinet/sctp_pcb.c
@@ -3298,6 +3298,10 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 	SCTP_INP_INFO_WLOCK_ASSERT();
 	SCTP_INP_WLOCK_ASSERT(inp);
 
+	printf("sctp_inpcb_bind_locked: inp=%p, addr=%p\n",
+	       (void*)inp, (void*)addr);
+	printf("sctp_inpcb_bind_locked: inp->sctp_flags=0x%x, UNBOUND=0x%x\n",
+	       inp->sctp_flags, SCTP_PCB_FLAGS_UNBOUND);
 #ifdef SCTP_DEBUG
 	if (addr) {
 		SCTPDBG(SCTP_DEBUG_PCB1, "Bind called port: %d\n",
@@ -3309,9 +3313,11 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 	if ((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) == 0) {
 		error = EINVAL;
 		/* already did a bind, subsequent binds NOT allowed ! */
+		printf("sctp_inpcb_bind_locked: already bound, returning EINVAL(%d)\n", error);
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);
 		goto out;
 	}
+	printf("sctp_inpcb_bind_locked: UNBOUND flag is set, continuing\n");
 	if (addr != NULL) {
 		switch (addr->sa_family) {
 #ifdef INET
@@ -3425,18 +3431,25 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 		{
 			struct sockaddr_conn *sconn;
 
+			printf("sctp_inpcb_bind_locked: AF_CONN case\n");
 #ifdef HAVE_SA_LEN
+			printf("sctp_inpcb_bind_locked: sa_len=%d, expected=%zu\n",
+			       addr->sa_len, sizeof(struct sockaddr_conn));
 			if (addr->sa_len != sizeof(struct sockaddr_conn)) {
 				error = EINVAL;
+				printf("sctp_inpcb_bind_locked: invalid sa_len\n");
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);
 				goto out;
 			}
 #endif
 			sconn = (struct sockaddr_conn *)addr;
 			lport = sconn->sconn_port;
+			printf("sctp_inpcb_bind_locked: AF_CONN port=%d, addr=%p\n",
+			       ntohs(lport), sconn->sconn_addr);
 			if (sconn->sconn_addr != NULL) {
 				bindall = 0;
 			}
+			printf("sctp_inpcb_bind_locked: bindall=%d\n", bindall);
 			break;
 		}
 #endif
@@ -3448,8 +3461,11 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 	}
 	/* Setup a vrf_id to be the default for the non-bind-all case. */
 	vrf_id = inp->def_vrf_id;
+	printf("sctp_inpcb_bind_locked: after switch, lport=%d, bindall=%d, vrf_id=%d\n",
+	       ntohs(lport), bindall, vrf_id);
 
 	if (lport) {
+		printf("sctp_inpcb_bind_locked: checking if port %d is in use\n", ntohs(lport));
 		/*
 		 * Did the caller specify a port? if so we must see if an ep
 		 * already has this one bound.
@@ -3500,6 +3516,7 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 					SCTP_INP_WLOCK(inp);
 					SCTP_INP_DECR_REF(inp);
 					error = EADDRINUSE;
+					printf("sctp_inpcb_bind_locked: port in use (bindall), EADDRINUSE=%d\n", error);
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);
 					goto out;
 				}
@@ -3527,6 +3544,7 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 				SCTP_INP_WLOCK(inp);
 				SCTP_INP_DECR_REF(inp);
 				error = EADDRINUSE;
+				printf("sctp_inpcb_bind_locked: port in use (not bindall), EADDRINUSE=%d\n", error);
 				SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);
 				goto out;
 			}
@@ -3534,6 +3552,7 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 	continue_anyway:
 		SCTP_INP_WLOCK(inp);
 		SCTP_INP_DECR_REF(inp);
+		printf("sctp_inpcb_bind_locked: continue_anyway, checking singleton\n");
 		if (bindall) {
 			/* verify that no lport is not used by a singleton */
 			if ((port_reuse_active == 0) &&
@@ -3544,12 +3563,15 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 					port_reuse_active = 1;
 				} else {
 					error = EADDRINUSE;
+					printf("sctp_inpcb_bind_locked: singleton port in use, EADDRINUSE=%d\n", error);
 					SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_PCB, error);
 					goto out;
 				}
 			}
 		}
+		printf("sctp_inpcb_bind_locked: port check passed\n");
 	} else {
+		printf("sctp_inpcb_bind_locked: no lport specified, auto-assigning\n");
 		uint16_t first, last, candidate;
 		uint16_t count;
 
@@ -3765,7 +3787,9 @@ sctp_inpcb_bind_locked(struct sctp_inpcb *inp, struct sockaddr *addr,
 	KASSERT((inp->sctp_flags & SCTP_PCB_FLAGS_UNBOUND) != 0,
 	    ("%s: inp %p is already bound", __func__, inp));
 	inp->sctp_flags &= ~SCTP_PCB_FLAGS_UNBOUND;
+	printf("sctp_inpcb_bind_locked: bind successful, clearing UNBOUND flag\n");
 out:
+	printf("sctp_inpcb_bind_locked: returning error=%d\n", error);
 	return (error);
 }
 
@@ -3784,7 +3808,13 @@ sctp_inpcb_bind(struct socket *so, struct sockaddr *addr,
 	struct sctp_inpcb *inp;
 	int error;
 
+	printf("sctp_inpcb_bind: so=%p, addr=%p\n",
+	       (void*)so, (void*)addr);
+
 	inp = so->so_pcb;
+	printf("sctp_inpcb_bind: inp=%p, flags=0x%x\n",
+	       (void*)inp, inp ? inp->sctp_flags : 0);
+
 	SCTP_INP_INFO_WLOCK();
 	SCTP_INP_WLOCK(inp);
 #if defined(__FreeBSD__) && !defined(__Userspace__)
@@ -3792,6 +3822,7 @@ sctp_inpcb_bind(struct socket *so, struct sockaddr *addr,
 #else
 	error = sctp_inpcb_bind_locked(inp, addr, sctp_ifap, p);
 #endif
+	printf("sctp_inpcb_bind: bind_locked returned %d\n", error);
 	SCTP_INP_WUNLOCK(inp);
 	SCTP_INP_INFO_WUNLOCK();
 	return (error);
diff --git a/usrsctplib/netinet/sctp_usrreq.c b/usrsctplib/netinet/sctp_usrreq.c
index 443cffe..829a35d 100755
--- a/usrsctplib/netinet/sctp_usrreq.c
+++ b/usrsctplib/netinet/sctp_usrreq.c
@@ -795,24 +795,48 @@ int
 sctpconn_bind(struct socket *so, struct sockaddr *addr)
 {
 	struct sctp_inpcb *inp;
+	int ret;
+
+	printf("sctpconn_bind: so=%p, addr=%p\n",
+	       (void*)so, (void*)addr);
 
 	inp = (struct sctp_inpcb *)so->so_pcb;
+	printf("sctpconn_bind: inp=%p, so_pcb=%p\n",
+	       (void*)inp, (void*)so->so_pcb);
+
 	if (inp == NULL) {
+		printf("sctpconn_bind: inp is NULL\n");
 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 		return (EINVAL);
 	}
+
+	printf("sctpconn_bind: inp->sctp_flags=0x%x, UNBOUND=0x%x\n",
+	       inp->sctp_flags, SCTP_PCB_FLAGS_UNBOUND);
+
 	if (addr != NULL) {
+		struct sockaddr_conn *sconn = (struct sockaddr_conn *)addr;
+		printf("sctpconn_bind: addr family=%d, AF_CONN=%d\n",
+		       addr->sa_family, AF_CONN);
 #ifdef HAVE_SA_LEN
+		printf("sctpconn_bind: addr len=%d, expected=%zu\n",
+		       addr->sa_len, sizeof(struct sockaddr_conn));
 		if ((addr->sa_family != AF_CONN) ||
 		    (addr->sa_len != sizeof(struct sockaddr_conn))) {
 #else
 		if (addr->sa_family != AF_CONN) {
 #endif
+			printf("sctpconn_bind: invalid addr family or len\n");
 			SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL);
 			return (EINVAL);
 		}
+		printf("sctpconn_bind: sconn_port=%d, sconn_addr=%p\n",
+		       ntohs(sconn->sconn_port), sconn->sconn_addr);
 	}
-	return (sctp_inpcb_bind(so, addr, NULL, NULL));
+
+	printf("sctpconn_bind: calling sctp_inpcb_bind\n");
+	ret = sctp_inpcb_bind(so, addr, NULL, NULL);
+	printf("sctpconn_bind: sctp_inpcb_bind returned %d\n", ret);
+	return ret;
 }
 
 #endif
diff --git a/usrsctplib/user_environment.c b/usrsctplib/user_environment.c
index 3deb3ef..b9699ad 100755
--- a/usrsctplib/user_environment.c
+++ b/usrsctplib/user_environment.c
@@ -374,6 +374,70 @@ read_random(void *buf, size_t size)
 	return;
 }
 
+void
+finish_random(void)
+{
+	return;
+}
+#elif defined(__RP2040_BM__)
+// RP2040 bare metal - use Pico SDK hardware RNG
+#include "pico/rand.h"
+
+void
+init_random(void)
+{
+	return;
+}
+
+void
+read_random(void *buf, size_t size)
+{
+	uint8_t *p = (uint8_t *)buf;
+	while (size >= 4) {
+		uint32_t r = get_rand_32();
+		memcpy(p, &r, 4);
+		p += 4;
+		size -= 4;
+	}
+	if (size > 0) {
+		uint32_t r = get_rand_32();
+		memcpy(p, &r, size);
+	}
+	return;
+}
+
+void
+finish_random(void)
+{
+	return;
+}
+#elif defined(__RP2040_BM__)
+// RP2040 bare metal - use Pico SDK hardware RNG
+#include "pico/rand.h"
+
+void
+init_random(void)
+{
+	return;
+}
+
+void
+read_random(void *buf, size_t size)
+{
+	uint8_t *p = (uint8_t *)buf;
+	while (size >= 4) {
+		uint32_t r = get_rand_32();
+		memcpy(p, &r, 4);
+		p += 4;
+		size -= 4;
+	}
+	if (size > 0) {
+		uint32_t r = get_rand_32();
+		memcpy(p, &r, size);
+	}
+	return;
+}
+
 void
 finish_random(void)
 {
diff --git a/usrsctplib/user_socket.c b/usrsctplib/user_socket.c
index ce9daed..3ab3b1e 100755
--- a/usrsctplib/user_socket.c
+++ b/usrsctplib/user_socket.c
@@ -108,8 +108,11 @@ usrsctp_init(uint16_t port,
              int (*conn_output)(void *addr, void *buffer, size_t length, uint8_t tos, uint8_t set_df),
              void (*debug_printf)(const char *format, ...))
 {
+	printf("usrsctp_init: port=%d, conn_output=%p\n", port, (void*)conn_output);
 	init_sync();
 	sctp_init(port, conn_output, debug_printf, 1);
+	printf("usrsctp_init: sctp_init completed, sctp_pcb_initialized=%d\n",
+	       SCTP_BASE_VAR(sctp_pcb_initialized));
 }
 
 
@@ -1330,23 +1333,33 @@ usrsctp_socket(int domain, int type, int protocol,
 {
 	struct socket *so = NULL;
 
+	printf("usrsctp_socket: domain=%d, type=%d, protocol=%d\n",
+	       domain, type, protocol);
+
 	if ((protocol == IPPROTO_SCTP) && (SCTP_BASE_VAR(sctp_pcb_initialized) == 0)) {
+		printf("usrsctp_socket: SCTP not initialized\n");
 		errno = EPROTONOSUPPORT;
 		return (NULL);
 	}
 	if ((receive_cb == NULL) &&
 	    ((send_cb != NULL) || (sb_threshold != 0) || (ulp_info != NULL))) {
+		printf("usrsctp_socket: invalid callback combination\n");
 		errno = EINVAL;
 		return (NULL);
 	}
 	if ((domain == AF_CONN) && (SCTP_BASE_VAR(conn_output) == NULL)) {
+		printf("usrsctp_socket: AF_CONN but no conn_output\n");
 		errno = EAFNOSUPPORT;
 		return (NULL);
 	}
+	printf("usrsctp_socket: calling socreate\n");
 	errno = socreate(domain, &so, type, protocol);
 	if (errno) {
+		printf("usrsctp_socket: socreate failed, errno=%d\n", errno);
 		return (NULL);
 	}
+	printf("usrsctp_socket: socreate success, so=%p, so_pcb=%p\n",
+	       (void*)so, (void*)so->so_pcb);
 	/*
 	 * The original socket call returns the file descriptor fd.
 	 * td->td_retval[0] = fd.
@@ -1476,19 +1489,39 @@ int
 usrsctp_bind(struct socket *so, struct sockaddr *name, int namelen)
 {
 	struct sockaddr *sa;
+	int gsa_err, bind_err;
+
+	printf("usrsctp_bind: so=%p, name=%p, namelen=%d\n",
+	       (void*)so, (void*)name, namelen);
 
 	if (so == NULL) {
+		printf("usrsctp_bind: so is NULL, returning EBADF\n");
 		errno = EBADF;
 		return (-1);
 	}
-	if ((errno = getsockaddr(&sa, (caddr_t)name, namelen)) != 0)
+
+	printf("usrsctp_bind: so->so_pcb=%p\n", (void*)so->so_pcb);
+
+	gsa_err = getsockaddr(&sa, (caddr_t)name, namelen);
+	printf("usrsctp_bind: getsockaddr returned %d, sa=%p\n",
+	       gsa_err, (void*)sa);
+	if (gsa_err != 0) {
+		errno = gsa_err;
 		return (-1);
+	}
+
+	printf("usrsctp_bind: calling sobind, sa_family=%d\n",
+	       sa->sa_family);
+	bind_err = sobind(so, sa);
+	printf("usrsctp_bind: sobind returned %d\n", bind_err);
 
-	errno = sobind(so, sa);
 	FREE(sa, M_SONAME);
+	errno = bind_err;
 	if (errno) {
+		printf("usrsctp_bind: failed with errno=%d\n", errno);
 		return (-1);
 	} else {
+		printf("usrsctp_bind: success\n");
 		return (0);
 	}
 }
diff --git a/usrsctplib/usrsctp.h b/usrsctplib/usrsctp.h
index e0c17c3..34ad402 100644
--- a/usrsctplib/usrsctp.h
+++ b/usrsctplib/usrsctp.h
@@ -43,6 +43,9 @@ extern "C" {
 #endif
 #include <winsock2.h>
 #include <ws2tcpip.h>
+#elif defined(CONFIG_USE_LWIP)
+#include <lwip/sockets.h>
+#include <lwip/inet.h>
 #else
 #include <sys/socket.h>
 #include <netinet/in.h>
